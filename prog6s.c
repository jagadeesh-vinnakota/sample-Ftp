/*
 Filename : prog4s.c
 Description : This file contains the program for the server which takes requests from the clients and sends responses to the clients. 
*/
/*
  ASSIGNMENT NUMBER: 4
  Name              : VINNAKOTA JAGADEESH
  ZID               : z1791612
 
*/
#include "prog6s.h"
#include "wrap6s.h"
#include "inOut.h"
//global variable to store the output generated by server
int main(int argc, char *argv[])
{
 // a variable to store port number
  uint16_t portno;
 //socklen_t variable to store the structure length of the client
  socklen_t clilen;
 if(argc != 2)
  {
     portno = SERV_PORT;   
   }
  else
   {
      portno = atoi(argv[1]);
    }
    //listen fd is used to store the return value of socket and connfd is used to store the value of accept function
    int listenfd, connfd;
	pid_t childpid;
    // structure to store socket information
    struct sockaddr_in servaddr,cliaddr;
    //calling the Socket wrapper function inorder to create a socket
    listenfd = Socket(DOMAIN, TYPE, PROTOCOL);
    // filling the structure variable with zeros to get rid of compilation errors
    bzero(&servaddr, sizeof(servaddr));
    //Filling the socket structure with necassary information
     servaddr.sin_family = DOMAIN;
     servaddr.sin_addr.s_addr = htonl(INADDR_ANY);
      servaddr.sin_port = htons(portno);
     //caling the Bind wrapper function to bind it to the socket
     Bind(listenfd, (SA *) &servaddr, sizeof(servaddr));
     //calling the Listen wrapper function in order to listen for the clients
     Listen(listenfd, LIST);
	 Signal(SIGCHLD,sig_chld);
     //calling the file wrapper inorder to open a file.
//     FILE* fp = Fopen(PATH,"r");
     //infinite loop to run a server continously.
     for( ; ; )
        {
        clilen = sizeof(cliaddr);          
         //calling the accept function if the server accepts the connection
         connfd = Accept(listenfd, (SA *) &cliaddr, &clilen);
		      if((childpid = Fork()) ==0)
			  {
				//closing the listening socket of child process.
				  Close(listenfd);
              //calling the cal function inorder to get the requested data. 
			  cal(connfd);
			//closing the connected socket of child process.
			  Close(connfd);
			   exit(0);
			  }
        //closing the connecting socket of father process.
          Close(connfd);
  }
// closing the listening socket of father process.
  Close(listenfd);
 //Close(connfd);
  //Fclose(fp);
 exit(0);
}
/*
  Function Name : cal
  Return : returns nothing.
  Description : This function will handle the clients request  and gives the response to the clients requests.
*/
  void cal(int connfd)
   {
    char recvline[1000];
    char* ch1;
    //printf("server");
    while(Readline(connfd,recvline,1000))
    {
      // recvline[strlen(recvline)] = '\0';
    //  printf("%d ",strlen(recvline));
      // printf("%s *",recvline);
       recvline[strlen(recvline)-1] ='\0'; 
      // printf("%s *",recvline);     
   //puts(recvline);
//  printf("%d \n",strcmp(recvline,"pwd"));
	if(strcmp(recvline,"pwd")==0)
	{
    //    for(int i=0;i<100;i++) { }
       printf(" \n");
//printf("1");
	ch1 = PWD();
 //printf("1");
	printf(" \n");
	 //printf("%d",strlen(ch1));
	
        bzero(recvline,1000);
        strcpy(recvline,ch1);
      //   ch1[strlen(ch1)-1] = '\n';
        recvline[strlen(recvline)] = '\n';
	// char bu[1000] = {"hello client \n"};
	  Writen(connfd,recvline,strlen(recvline));
        bzero(recvline,1000);
	}
        else if(strcmp(recvline,"cdup")==0)
	{
	  bzero(recvline,1000);
	  int er = chdir("..");
          if(er==0)
		{
		 recvline[0] = '0';
		recvline[1]='\n'; 
		}
		else
		{
		 recvline[0] ='1';
		recvline[1]='\n';
		}
 	   Writen(connfd,recvline,strlen(recvline));
	   bzero(recvline,1000);  
	}
	else
	{
        // puts(recvline);
          char* even = NULL; char* cm=NULL; char* cm1 = NULL;
          even = strtok(recvline," ");
         if(even!=NULL) { cm = (char*) malloc(strlen(even)*sizeof(char));
                              strcpy(cm,even);//cm = even;
 }
           even = strtok(NULL," ");
         if(even!=NULL)
          {
		cm1 = (char*) malloc(strlen(even)*sizeof(char));
           strcpy(cm1,even);//    cm1 = even;
	}
//printf("%s*",cm);printf("%s*",cm1);	  
if(strcmp(cm,"cd") ==0) {
                       int e;
                              if((strcmp(cm1,"~") ==0))
				 {
//printf("tilda came");
				   e = chdir(getenv("HOME"));
			         	}
                              
			else	{	 e = chdir(cm1); }
					if(e==0)
					{
					 recvline[0] = '0';recvline[1]='\n';
					}
					else
					{
					recvline[0]='1';recvline[1]='\n';
					}
  //                       printf("%s",recvline);
				Writen(connfd,recvline,strlen(recvline));
				bzero(recvline,1000);
				 }
	}
}
}
/*char* PWD()
{
char* ch;
 getcwd(ch,1000);
// printf("%s",ch);
return ch;
}*/
 // function used to avoid the zombie processes.  
void sig_chld()
{

	int stat;
	//calling the waitpid function in a loop to handle the terminated child processes.
	 Wait(&stat);
}
